<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Fira+Mono|Merriweather:300|Open+Sans);

      body {
        font-family: 'Merriweather', serif;
      }
      body.remark-container {
        background: #000;
        color: #ddd;
      }
      .remark-slide-scaler {
          transform-origin: top-left;
          -moz-box-shadow: 0 0 30px #222;
          -webkit-box-shadow: 0 0 30px #222;
          box-shadow: 0 0 30px #222;
      }
      .remark-slide-content {
        background: #222;
      }
      h1, h2, h3, h4 {
        font-family: 'Open Sans', sans-serif;
        font-weight: bold;
      }
      /*
      p + ul, li + li {
        margin-top: -0.66em;
      }
      */
      .remark-code, .remark-inline-code {
        background: black;
        font-family: 'Fira Mono', monospace;
        border-radius: 5px;
        padding: .5em;
      }
      .remark-inline-code {
        background: #111;
        border-radius: 5px;
        padding: .2em;
      }
      .remark-code-span-highlighted {
        background-color: rgba(255, 255, 0, 0.35);
        border-radius: 5px;
        border: 1.5px solid #BB0;
      }
      .remark-code-line-highlighted {
        background-color: rgba(255, 255, 0, 0.35);
        border-width: 0px 2px;
        border-style: solid;
        border-color: #BB0;
      }
      
      /* Two-column layout */
      .left-column {
        color: #888;
        width: 20%;
        height: 92%;
        float: left;
      }
      /*
      .left-column h3 {
        margin: 0.5em 0em 0em 0.5em;
        font-size: 120%;
      }
      .left-column h4 {
        margin: 0.5em 0em 0em 1.5em;
        font-size: 100%;
      }
      */
      .left-column .current {
        color: #ddd;
      }
      .right-column {
        width: 75%;
        float: right;
        /*padding-top: 1em;*/
      }
      .clear {
        clear: both;
      }
    </style>
  </head>
  <body>
    <textarea id="source" style="display: none">

class: center, middle

# Title

---

<!--- layout: true --->

# Layout

---

# Overview

1. Why a new programming language?
2. Deep-dive
3. ...

---

# Why program in Kotlin?

--

Not because it's a panacea

(TODO: Quote about failure reason being that you're doing the wrong thing.)

---

# Why program in Kotlin?

## Because it's delightful!

--

... and also

--

* cross-ecosystem

--

* powerful

--

* elegant

--

* easy to learn

--

* professional

---

# Delightful features (IMHO)

Cross-ecosystem

Type inference

Types are non-nullable by default

No checked exceptions

Inline functions + lambdas = syntactic macros & type-safe builders

Property delegation

Class delegation

Coroutines

???

These slides will skip most details of features which are similar to other languages focus on the cool bits :-)

---

.left-column[
### Delightful features
]
.right-column[
# Cross-ecosystem
]
.clear[
Apply the same language cross-platform and cross-stack

Compile to JVM, JavaScript, or native code (alpha)

Standard cross-platform libary

Easy access to other platform libraries

In future, build multi-platform modules
]

---

.left-column[
### Delightful features
]
.right-column[
# Cross-ecosystem: JVM
]
.clear[
Based on JDK 7, 8, or 9

Easy to learn if you know Java (or Groovy, or C#)

Great interop both ways

Officially supported by Google for Android

Officially supported by Spring
]

???

Can't generate JDK 9 modules, as of 1.1.3.

---

.left-column[
### Delightful features
]
.right-column[
# Cross-ecosystem: JavaScript
]
.clear[
More powerful than TypeScript or Flow

Client-side in browser

Server-side in Node.js

Define strongly-typed interfaces to JS modules

* `ts2kt` tool to _mostly_ translate from TypeScript

Build your own standard JS modules
]

???

Not a strict supserset of Flow (e.g., no union types) but does more than just provide better type info.

---

.left-column[
### Delightful features
]
.right-column[
# Cross-ecosystem: Native
]
.clear[
Alpha quality

LLVM-based

Efficient, type-safe access to C

* `cinterop` generates Kotlin wrappers from C headers

Create EXEs and multi-platform static libraries

Platforms: Ubuntu Linux, Raspberry Pi, iOS, MacOS, Windows

GC: Automatic ref-counting with cycle detection
]

???

https://blog.jetbrains.com/kotlin/2017/04/kotlinnative-tech-preview-kotlin-without-a-vm/

https://github.com/JetBrains/kotlin-native/blob/v0.1.0/INTEROP.md

https://blog.jetbrains.com/kotlin/2017/06/kotlinnative-v0-3-is-out/

---
.left-column[
### Delightful features
]
.right-column[
# Non-nullable types
]
.clear[
```
class Person(
        val name: `String`,
        var nickname: String`?` = null
) {

    fun sayHello() {
        val splitNick = nickname`?.`split(' ')
        val myName = when(splitNick?.size) {
            null -> name
            // At this point Kotlin knows splitNick is not null
            1 -> nickname `?:` name
            else -> splitNick.map { it.first() }.joinToString()
        }
        println("Hello, my name is $myName")
    }
}
```
]

???

If you call a Java API, Kotlin lets you treat it as nullable or not.
If you treat it as non-nullable and it is in fact `null`, you'll get a
`NullPointerException` as soon as you try to use it.

The compiler knows about various standard Java annotations for annotating nullability
so, if a libary you're calling makes use of them, the compiler will take them into
account to give you warnings/errors when you call methods and handle return values.

This slide also shows type inference; see following slides for more detail.

---

.left-column[
### Delightful features
]
.right-column[
# Type inference 1/2
]
.clear[
```
// size inferred as Double
var `size` = 10.0
fun foo1() {
    size = 11 // compile error
}

fun <T> forEach(items: Collection<T>, block: (T) -> Unit) {
    // item inferred as T
    for (`item` in items) block(item)
}

fun foo2() {
    // it inferred as Int
    forEach(listOf(1, 2, 3)) { print(`it` + 1) }
}
```
]

???

---

.left-column[
### Delightful features
]
.right-column[
# Type inference 2/2
]
.clear[
```
// Return type defaults to Unit (like void)
fun <T> maybeDo(o: T?, block: (T) -> Unit) {
    if (`o != null`) {
        // o inferred as T (not T?)
        block(`o`)
    }
}

fun throwAnything(o: Any): Nothing = when(o) {
    `is Throwable` -> throw o // o inferred as Throwable
    `is String` -> throw Exception(o) // o inferred as String
    else -> throw Exception(o.toString())
}
```
]

???

The definition of `throwAnything` shows the shorthand for a single-expression function.

The return type of `Nothing` means "does not return".  The compiler will, for example,
warn you about dead code if you have any code after a call to function returning `Nothing`.

---

.left-column[
### Delightful features
]
.right-column[
# No checked exceptions
]
.clear[
The theory of checked exceptions is: they are part of an API, so they should be explicit.

* That's only useful when there's something you can do about a particular case of error.

* It's only useful if the exceptions distinguish each kind of error.

* Layering is verbose, with `try/catch` and per-layer exception classes.
]

???
---

.left-column[
### Delightful features
]
.right-column[
# Inline functions + lambdas
]
.clear[
```
 `inline` fun <T: Closeable?> T.autoClose(block: (T) -> Unit) {
    var caught: Boolean = false
    try {
        block(this)
    } catch (e: Exception) {
        caught = true
        try { this?.close() }
        catch (e2: Exception) { e.addSuppressed(e2); throw e }
    } finally {
        if (!caught) { this?.close() }
    }
}

fun getFirstLineStartingWith(fileName: String, prefix: String): String? {
    FileReader(File("foo.txt")).autoClose {
        it.useLines { it.forEach { if (it.startsWith(prefix)) `return` it } }
    }
    return null
}
```
]

???

`autoClose`, `useLines`, `forEach` and the innermost block are all inlined
into `getFirstLineStartingWith`, so the `return` will return from that
function.

Keywords `noinline` and `crossinline` allow you to declare restrictions
on how function-typed arguments can be inlined.

---

.left-column[
### Delightful features
]
.right-column[
# Property delegation: lazy
]
.clear[
```
inline fun retry(count: Int, block: () -> Unit) {
    val exceptions `by lazy` { LinkedList<Exception>() }
    for (i in 0 until count) {
        try { block(); return }
        catch (e: Exception) { exceptions.add(e) }
    }
    val message = when (exceptions.size) {
        0 -> "Count must be a positive integer"
        1 -> throw exceptions[0]
        else -> "Failed after $count retry attempts"
    }
    throw RuntimeException(message).apply {
        for (e in exceptions) addSuppressed(e)
    }
}
```
]

???

`lazy` is a delegate from the Kotlin standard library, along with `observable` and `vetoable`

In this example, the linked list of exceptions is not created until it's needed.

---

.left-column[
### Delightful features
]
.right-column[
# Property delegation: SQL 1/3
]
.clear[
```
interface HasSqlId {
    val table: String
    val pkCol: String
    val id: Int
}

object DbConfig {
    lateinit var url: String
}

class Vehicle(override val id: Int) : HasSqlId {
    override val table = "vehicle"
    override val pkCol = "id"
    var type: String `by sql()`
    var make: String by sql()
    var model: String by sql()
}
```
]

???

Here's an example using a custom delegate.  A delegate object has to provide two 

---

.left-column[
### Delightful features
]
.right-column[
# Property delegation: SQL 2/3
]
.clear[
```
class SqlDelegateFactory {
    operator fun provideDelegate(thisRef: HasSqlId, prop: KProperty<*>):
            ReadWriteProperty<HasSqlId, String> {
        DriverManager.getConnection(DbConfig.url).use {
            it.prepareStatement("select 1 from ${thisRef.table} where 1 = 0").use {
                it.execute() // throws if table doesn't exist
            }
        }
        return SqlDelegate()
    }
}

fun `sql()` = SqlDelegateFactory()
```
]

???
---

.left-column[
### Delightful features
]
.right-column[
# Property delegation: SQL 3/3
]
.clear[
```
class SqlDelegate : ReadWriteProperty<HasSqlId, String> {
    private fun getStmt(thisRef: HasSqlId, property: KProperty<*>) =
            "SELECT ${property.name} FROM ${thisRef.table} WHERE ${thisRef.pkCol} = ?"
            
    override fun getValue(thisRef: HasSqlId, property: KProperty<*>): String {
        DriverManager.getConnection(DbConfig.url).use {
            it.prepareStatement(getStmt(thisRef, property)).use {
                it.setInt(1, thisRef.id)
                it.executeQuery().use {
                    return if (it.first()) it.getString(property.name)
                    else throw IllegalArgumentException("ID ${thisRef.id} not found")
                }
            }
        }
    }
    
    override fun setValue(thisRef: HasSqlId, property: KProperty<*>, value: String) = `TODO()`
}
```
]

???

Delegates don't have to implement the `ReadWriteProperty` or `ReadOnlyProperty` interfaces,
they just have to provide `operator fun getValue`/`setValue` with the right signature.

The `TODO()` function always throws a "not implemented" exception.

---

.left-column[
### Delightful features
]
.right-column[
# Class delegation
]
.clear[
```
class LimitedIterator<T>(
        val limit: Int,
        private val wrapped: Iterator<T>
): Iterator<T> by wrapped {
    private var count = 0

    override fun next(): T {
        if (++count > limit) {
            throw IllegalStateException("No more than $limit items can be read")
        }
        return wrapped.next()
    }

    override fun hasNext(): Boolean {
        return count < limit && wrapped.hasNext()
    }
    
    // No override of 'remove', so it's just delegated to 'wrapped'.
}
```
]

???
---

.left-column[
### Delightful features
]
.right-column[
# Coroutines
]
.clear[
Suspend execution of a code block without blocking a thread; resume on any thread later.

* Compiler converts the block to a state machine.

* Suspend/resume at calls to any `suspend fun`.

Extension of C#2/ES6 generators/`yield`, C#5/ES7 `async`/`await`, Go channels/`select`, ...

Your code can freely customise dispatch of coroutines.

Coroutines can be serialisable so

* "any thread" can be in another process;

* "later" can be after reloading from persistent store.
]

???
---

.left-column[
### Delightful features
]
.right-column[
# Coroutines: JS callbacks
]
.clear[
```JavaScript
$.ajax("https://server/api/firstStep", {
    success: function (data, status, req) {
        var key = data;
        $.ajax("https://server/api/secondStep?key=" + key, {
            success: function (data, status, req) {
                window.setTimeout(function() { $("#result").text(data); }, 0);
            },
            error: function (req, status, error) {
                window.setTimeout(function() { $("#result").text("Invalid key: " + key); }, 0);
            }
        })
    },
    error: function (req, status, error) {
        window.setTimeout(function() { $("#result").text("Failed to get key: " + error); }, 0);
    }
});
```
]

???
---

.left-column[
### Delightful features
]
.right-column[
# Coroutines: JS Promises
]
.clear[
```JavaScript
var key = data
$.ajax("https://server/api/firstStep")
    .then(function (data, status, req) {
        key = data;
        $.ajax("https://server/api/secondStep?key=" + key)
    })
    .catch(function (req, status, error) {
        window.setTimeout(function() { $("#result").text("Invalid key: " + key); }, 0);
    })
    .then(function (data, status, req) {
        window.setTimeout(function() { $("#result").text(data); }, 0);
    })
    .catch(function (req, status, error) {
        window.setTimeout(function() { $("#result").text("Failed to get key: " + error); }, 0);
    };
```
]

???
---

.left-column[
### Delightful features
]
.right-column[
# Coroutines: Kotlin JS 1/2
]
.clear[
```
fun doAjax() = async {
    fun showResult(result: Any?) =
            window.setTimeout({ jQuery("#result").text(result.toString()) })
    var key: Any? = null
    try {
        key = jQuery.ajax("https://server/api/firstStep").await()
        showResult(jQuery.ajax("https://server/api/secondStep?key=$key").await())
    } catch(e: Exception) {
        if (key == null) {
            showResult("Failed to get key: ${e.message}")
        } else {
            showResult("Invalid key $key: ${e.message}")
        }
    }
}
```
]

???

This example assumes the existence of `external` definitions for jQuery, and of
the definition for JavaScript's `Promise` type in the Kotlin standard library.
.

---

.left-column[
### Delightful features
]
.right-column[
# Coroutines: Kotlin JS 2/2
]
.clear[
```
external interface JQueryPromise<out T> { 
    fun then( // Real definition has other overloads ...
        doneFilter: (value: T?, values: Any) -> Unit,
        failFilter: ((reasons: Any) -> Any)? = definedExternally
    ): JQueryPromise<Unit>
}

fun <T> async(c: suspend () -> T): Promise<T> {
    return Promise { resolve, reject ->
        c.startCoroutine(object : Continuation<T> {
            override fun resume(value: T) = resolve(value)
            override fun resumeWithException(exception: Throwable) = reject(exception)
            override val context = EmptyCoroutineContext
        })
    }
}

inline suspend fun <T> JQueryPromise<T>.await() = suspendCoroutine<T?> { c ->
    then({ v, vs -> c.resume(v) }, { reasons -> c.resumeWithException(reasons as Throwable) })
}
```
]

???
---


.left-column[
## Why?
### Cross-ecosystem
### .current[Powerful]
### Elegant
### Easy
### Professional
]
.right-column[
# Powerful

Multi-paradigm

* OOP
* Procedural
* Higher-order functions
* Generics

Extensible

* Extension functions
* Inline functions + lambdas = block macros & type-safe builders
* Coroutines
]

---

.left-column[
## Why?
### Cross-ecosystem
### Powerful
### .current[Elegant]
### Easy
### Professional
]
.right-column[
# Elegant

Concise

* Type inference
* Auto-generated accessors for fields
* Define fields within default constructor
* Data classes

Same concepts used in different contexts

* Properties, delegated properties, functions, and extension functions  
can be global, class-local, or function-local
* Constructors and factory methods have the same syntax
* Coroutine mechanism can be extended to  
async calls, sequence generators, channels, thread pools, etc.
]

---

.left-column[
## Why?
### Cross-ecosystem
### Powerful
### Elegant
### .current[Easy]
### Professional
]
.right-column[
# Easy

Easy to learn if you know Java, C#, or TypeScript

Principle of least surprise

Good documentation and examples

Active communities on forums, StackOverflow, Slack, etc.
]

---

.left-column[
## Why?
### Cross-ecosystem
### Powerful
### Elegant
### Easy
### .current[Professional]
]
.right-column[
# Professional

Commercially supported by creators, JetBrains

* Used internally for their products

Well supported even in free version of IntelliJ IDEA

Also integrates with Eclipse, Android Studio, Maven, Gradle

* You can even write Gradle scripts in Kotlin!

Compiler is open source (Apache licence)
]

---

.left-column[
## Delightful!
### Awesome things
### Syntactic sugar
### Nice surprises
]
.right-column[
# Professional

Commercially supported by creators, JetBrains

* Used internally for their products

Well supported even in free version of IntelliJ IDEA

Also integrates with Eclipse, Android Studio, Maven, Gradle

* You can even write Gradle scripts in Kotlin!

Compiler is open source (Apache licence)
]

---

# Code Sample

```
class MapWithDefault<K, out V>(
        private val m: MutableMap<K, V>,
        private val defaultValue: () -> V
) : Map<K, V> `by m` {
    override fun get(key: K): V? = m.getOrPut(key, defaultValue)
}
```

--

```
fun <K, V> MutableMap<K, V>.withDefaultValue(
        defaultValue: () -> V
): Map<K, V> = MapWithDefault(this, defaultValue)
```


---


Co- and contra-variance at both declaration and use sites.

---

# Parsimony

## Extensions

Extension methods and properties can exist at top-level, within a class, or within a function.

## Property delegation

Delegated properties can exist at top-level, within a class, or within a function.

Property delegation is based on objects, not classes, so you can use singleton objects as delegates.


---

# Gotchas

Ranges are open at both ends: `1..10` is "1, 2, ..., 10"


    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({
        ratio: '16:9',
        highlightLanguage: 'kotlin',
        highlightStyle: 'tomorrow-night-bright',
        highlightSpans: true,
        highlightLines: true,
      });
    </script>
  </body>
</html>